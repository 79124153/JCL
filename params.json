{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Jar Class Loader, a configurable and dynamic custom classloader designed to create, manage and manipulate isolated Java classloaders in IoC frameworks and web applications.","name":"jcl","google":"","body":"Overview\r\n========\r\n\r\nJCL is a configurable, dynamic and extensible custom classloader that\r\nloads java classes directly from Jar files and other sources. The\r\nmotivation was to create isolated classloaders, which can be easily\r\nintegrated with IoC frameworks like Spring and with web applications.\r\n\r\nThe entire library, including it’s code-base and documentation is\r\navailable under a dual-license, whereby it can be used under the terms\r\nand conditions of [LGPL](http://www.gnu.org/licenses/lgpl.html) and\r\n[Apache License 2.0](http://www.apache.org/licenses/LICENSE-2.0).\r\n\r\nInstallation\r\n============\r\n\r\nTo use JCL, download and build the JCL project and put jcl\r\n(~~core~~2.x).jar and dependencies in the application’s classpath. See\r\nthe build section below and also check out the downloads section for\r\nmore details on the available builds and source.\r\n\r\nJCL is also available in Maven Central Repository, which makes it very\r\neasy to use in maven projects as a dependency.\r\n\r\nBuilding JCL\r\n============\r\n\r\nJCL is a multi-module maven project that has four modules as shown\r\nbelow:\r\n\r\n    <code>\r\n     JCL\r\n      |---> core\r\n      |---> spring\r\n      |---> test-jcl\r\n      |---> test-web\r\n    </code>\r\n\r\nThe test-\\* modules create resources to run the unit tests and a sample\r\nweb application. The core module builds an artifact with all the main\r\nJCL class files. The spring module generates an artifact for spring\r\nintegration.\r\n\r\nTo build JCL, check-out the source code of JCL2 from\r\n[github](https://github.com/xeusman/JCL) and run the following command:\r\n\r\n    <code>\r\n     mvn clean install\r\n    </code>\r\n\r\nThis command will create jcl-core and jcl-spring artifacts, and will\r\nalso create a sample war file to test JCL web integration. It will also\r\ncopy the dependencies of each artifact in the dependecies folder.\r\n\r\nRequirements\r\n============\r\n\r\nJCL requires JDK 1.5 or later; and will pull in all its dependencies\r\nusing maven.\r\n\r\nUsage\r\n=====\r\n\r\nBelow is a little tutorial on JCL v2 with examples. Please also see the\r\noverview section for installation.\r\n\r\nWhat’s new in v2\r\n----------------\r\n\r\nVersion 2.x now deprecates version 1.x so we recommend users to switch\r\nto version 2, which was a complete refactoring of version 1 and has a\r\nbetter design with a lot more features. Following is a list of *some*\r\nupdates and changes in v2.x:\r\n\r\n-   Total refactoring of version 1\r\n-   Maven is being used for project management instead of ANT\r\n-   Added more robust spring and web support\r\n-   Added OSGi boot loading\r\n-   JCL 2 is more customizable and configurable\r\n-   etc. etc.\r\n\r\nUsing JCL\r\n---------\r\n\r\nJCL is a light weight API and has only a few but useful classes. Here is\r\na simple example on how to programmatically use JCL. JarClassLoader has\r\nan arguments-constructor and add methods that take jar-file/class-folder\r\npaths, URLs and InputStreams.\r\n\r\n    <code>\r\n      JarClassLoader jcl = new JarClassLoader();\r\n\r\n      //Loading classes from different sources\r\n      jcl.add(\"myjar.jar\");\r\n      jcl.add(new URL(\"http://myserver.com/myjar.jar\"));\r\n      jcl.add(new FileInputStream(\"myotherjar.jar\"));\r\n      jcl.add(\"myclassfolder/\");\r\n\r\n      //Recursively load all jar files in the folder/sub-folder(s)\r\n      jcl.add(\"myjarlib/\");\r\n\r\n      JclObjectFactory factory = JclObjectFactory.getInstance();\r\n\r\n      //Create object of loaded class\r\n      Object obj = factory.create(jcl, \"mypack.MyClass\");\r\n    </code>\r\n\r\nNow we can use reflection to invoke methods of this object. It is also\r\npossible to create object proxies and call methods the normal way, this\r\nis done by using cast (able) methods available in JclUtils class\r\nexplained later.\r\n\r\nCreating a JCL Context\r\n----------------------\r\n\r\nIn order to access the created JarClassLoader instance from any where in\r\nthe application a *JclContext* must be created. The\r\n*DefaultContextLoader* provides a way to create this context for a\r\nsingle programmatically created JarClassLoader instance.\r\n\r\n    <code>\r\n      JarClassLoader jcl = new JarClassLoader();\r\n      jcl.add(\"myjarlib/\");\r\n\r\n      DefaultContextLoader context=new DefaultContextLoader(jcl);\r\n      context.loadContext();\r\n    </code>\r\n\r\nNow “jcl” can be accessed from anywhere in the application as follows.\r\n\r\n    <code>\r\n      JarClassLoader jcl=JclContext.get(); // returns the Default JCL instance\r\n    </code>\r\n\r\nIt is also possible to create an XML configuration file for JCL and use\r\n*XmlContextLoader* to create the context.\r\n\r\nUsing JCL in Web Applications\r\n-----------------------------\r\n\r\nOne of the motivations behind JCL was to be able to create multiple\r\nisolated classloaders in a single web application hosted on application\r\nservers like JBoss, Tomcat etc. This is achieved with\r\nJclContextLoaderListener.\r\n\r\nThe JCL configuration is put in a XML file and then the\r\n*JclContextLoaderListener* is used to load the context. Below is an\r\nexample of JCL XML configuration.\r\n\r\n    <code>\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    <jcl-context>\r\n        <jcl name=\"jcl1\">\r\n            <loaders>\r\n                <loader name=\"jcl.parent\">\r\n                    <order>3</order>\r\n                    <enabled>true</enabled>\r\n                </loader>\r\n                <loader name=\"jcl.local\">\r\n                    <order>1</order>\r\n                    <enabled>true</enabled>\r\n                </loader>\r\n                <loader name=\"jcl.current\">\r\n                    <enabled>false</enabled>\r\n                </loader>\r\n                <loader name=\"jcl.thread\">\r\n                    <enabled>true</enabled>\r\n                </loader>\r\n                <loader name=\"jcl.system\">\r\n                    <enabled>true</enabled>\r\n                </loader>\r\n                <loader name=\"jcl.bootosgi\">\r\n                    <enabled>true</enabled>\r\n                    <strict>true</strict>\r\n                    <bootDelegation>mypack.system.*</bootDelegation>\r\n                </loader>\r\n                <loader name=\"custom\" class=\"mypack.MyLoader\">\r\n                    <order>2</order>\r\n                    <enabled>true</enabled>\r\n                </loader>\r\n            </loaders>\r\n            <sources>\r\n                <source>webapp:WEB-INF/mylib/myjar.jar</source>\r\n                <source>webapp:myotherjar.jar</source>\r\n            </sources>\r\n        </jcl>\r\n        <jcl name=\"jcl2\">\r\n            <sources>\r\n                <source>webapp:WEB-INF/myjarlib/</source>\r\n            </sources>\r\n        </jcl>\r\n    </jcl-context>\r\n    </code>\r\n\r\nIn this example two classloaders are created in a single context. The\r\nsource paths starting with **webapp:** are treated as paths to internal\r\nweb application jar files and folders. After this configuration, the\r\ncontext can be loaded in the web application by adding the\r\nJclContextLoaderListener in the application’s web.xml file.\r\n\r\n    <code>\r\n     <context-param>\r\n        <param-name>jcl-context</param-name>\r\n        <param-value>\r\n          classpath:jcl.xml\r\n        </param-value>\r\n      </context-param>\r\n\r\n      <listener>\r\n        <listener-class>org.xeustechnologies.jcl.web.JclContextLoaderListener</listener-class>\r\n      </listener>\r\n    </code>\r\n\r\nThe JCL instances can then be accessed by name from anywhere in the web\r\napplication as shown below.\r\n\r\n    <code>\r\n      JarClassLoader jcl1=JclContext.get(\"jcl1\");\r\n      JarClassLoader jcl2=JclContext.get(\"jcl2\");\r\n    </code>\r\n\r\n### Sample web application\r\n\r\nThe JCL project also includes a sample web application that demonstrates\r\nJCL web-app integration. The jcltest.war file is created in the test-web\r\nmodule at jcl-project/test-web/target when the project is built. The\r\ncontent of the war file is also under the same module and is located in\r\njcl-project/test-web/src/main folder. The exploded war folder contains\r\nall the files that clearly shows the usage of JCL in web applications.\r\n\r\nAfter deploying the sample web application, go to\r\n[http://server-name:8080/jcltest](http://server-name:8080/jcltest); this\r\nwill print “Hello World” on the screen with classloader details. This\r\nmessage is returned from a JCL-loaded object, see\r\njcl-project/test-web/src/main/jcltest.war/index.jsp for more details.\r\n\r\nUsing JCL with Spring Framework\r\n-------------------------------\r\n\r\nJCL can be used with spring framework. JCL v2 provides Spring XML\r\nextension to load beans via JCL. The JCL bean is created using the new\r\n**jcl:jcl** element and spring beans can reference the jcl bean by using\r\nthe **jcl:jcl-ref** element as shown in the example below. These\r\nelements are defined in the jcl-schema.xsd. This also works well in a\r\nweb application using the Spring ContextLoaderListener. In addition to\r\nthis JCL v2 also supports the older way of Spring integration, please\r\nsee the spring-test.xml file provided with the source.\r\n\r\n    <code>\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n        xmlns:jcl=\"http://www.xeustechnologies.org/schema/jcl\"\r\n        xsi:schemaLocation=\"\r\n    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\r\n    http://www.xeustechnologies.org/schema/jcl http://www.xeustechnologies.org/schema/jcl/jcl.xsd\">\r\n\r\n        <jcl:jcl id=\"jcl1\">\r\n            <constructor-arg>\r\n                <list>\r\n                    <value>target/test-jcl.jar</value>\r\n                </list>\r\n            </constructor-arg>\r\n        </jcl:jcl>\r\n\r\n        <jcl:jcl id=\"jcl2\">\r\n            <constructor-arg>\r\n                <list>\r\n                    <value>target/test-jcl.jar</value>\r\n                </list>\r\n            </constructor-arg>\r\n        </jcl:jcl>\r\n\r\n        <bean id=\"test1\" class=\"org.xeustechnologies.jcl.test.Test\">\r\n            <jcl:jcl-ref ref=\"jcl1\" />\r\n            <constructor-arg ref=\"name\"/>\r\n            <property name=\"lastName\">\r\n                    <value>Zafar</value>\r\n            </property>\r\n        </bean>\r\n\r\n        <bean id=\"name\" class=\"java.lang.String\">\r\n            <jcl:jcl-ref ref=\"jcl2\" />\r\n            <constructor-arg>\r\n                <value>Kamran</value>\r\n            </constructor-arg>\r\n        </bean>\r\n    </beans>\r\n    </code>\r\n\r\nCasting objects of types loaded in JCL\r\n--------------------------------------\r\n\r\nJava does not allow casting objects of types loaded in a different\r\nclassloader; such casting attempt results in a *ClassCastException*. But\r\nsometimes it is necessary to cast objects to obtain interface references\r\nloaded in the current classloader. E.g. suppose that an API\r\nimplementation is loaded using JCL and the API itself is loaded in the\r\ncurrent classloader, now it is easy to use the interface reference to\r\ninvoke methods than using reflection. JCL provides a few ways to obtain\r\ninterface references and to convert the JCL-loaded objects into castable\r\nobjects. This is actually done by internally creating proxies for the\r\nJCL-loaded objects. JCL, as of version 2.2, can also create\r\n[cglib](http://cglib.sourceforge.net/) dynamic proxies apart from the\r\nregular jdk proxies, which makes it possible to create proxies for any\r\nclass not just interfaces. It is also possible to create\r\nauto-proxies/castable-objects from the object factory, which is very\r\nhandy because then the objects can be used and casted the normal way.\r\n\r\n### Auto creating castable objects from factory\r\n\r\nIn version 2.2 and later, the JclObjectFactory can be used to\r\nauto-create “castable” objects, by passing true to the getInstance\r\nmethod. Now every time an object is created, it can be casted to\r\nreferences in the current classloader without the need of JclUtils. By\r\ndefault JCL2 uses jdk proxies but that can be changed by specifying the\r\nproxy provider, as shown in the example below.\r\n\r\n    <code>\r\n      JarClassLoader jcl = new JarClassLoader();\r\n      jcl.add(\"myapi-impl.jar\"); //Load jar file\r\n\r\n      // Set default to cglib (from version 2.2.1)\r\n      ProxyProviderFactory.setDefaultProxyProvider( new CglibProxyProvider() );\r\n\r\n      //Create a factory of castable objects/proxies\r\n      JclObjectFactory factory = JclObjectFactory.getInstance(true);\r\n\r\n      //Create and cast object of loaded class\r\n      MyInterface mi = (MyInterface) factory.create(jcl,\"myapi.impl.MyInterfaceImpl\");\r\n    </code>\r\n\r\nAuto proxying can also be dynamically enabled using a jvm command line\r\nargument:\r\n\r\n    <code>\r\n      -Djcl.autoProxy=true\r\n    </code>\r\n\r\n### Casting objects when required\r\n\r\nBy default the object factory creates objects of classes loaded in JCL\r\nwithout proxies. So in order to cast/clone the objects, JclUtils class\r\nis used as shown in the example below:\r\n\r\n    <code>\r\n      JarClassLoader jcl = new JarClassLoader();\r\n      jcl.add(\"myapi-impl.jar\"); //Load jar file\r\n\r\n      //Create default factory\r\n      JclObjectFactory factory = JclObjectFactory.getInstance();\r\n\r\n      //Create object of loaded class\r\n      Object obj = factory.create(jcl,\"myapi.impl.MyInterfaceImpl\");\r\n\r\n      //Obtain interface reference in the current classloader\r\n      MyInterface mi = JclUtils.cast(obj, MyInterface.class);\r\n\r\n      //Convert the object into a castable object in the current classloader (jdk proxy)\r\n      MyInterface mi1 = (MyInterface) JclUtils.toCastable(obj, MyInterface.class);\r\n\r\n      //Clone \"Serializable\" object into a castable object in the current classloader\r\n      //The JCL-loaded object must implement Serializable\r\n      //This method is now deprecated and the use of deepClone is recommended\r\n      MyInterface mi2 = (MyInterface) JclUtils.clone(obj);\r\n\r\n      //Clone any object Serializable and non-Serializable\r\n      MyInterface mi2 = (MyInterface) JclUtils.deepClone(obj);\r\n    </code>\r\n\r\nManipulating class loading order & adding custom classloaders\r\n-------------------------------------------------------------\r\n\r\nJCL v2 by default looks for classes in five places in order, local JCL\r\nclass loader (order=1), current class loader (order=2), parent class\r\nloader (order=3), in thread context class loader (order=4) and then in\r\nsystem class loader (order=5). There is a sixth class loader available\r\nfor Osgi boot delegation; it is described later in the document. In\r\naddition to built-in loaders, more class loaders can be added by\r\nextending the *org.xeustechnologies.jcl.ProxyClassLoader* class. Each\r\nloader has a loading order and the default loading orders can be\r\nchanged. Below is an example that shows how to do this:\r\n\r\n    <code>\r\n      JarClassLoader jcl=new JarClassLoader();\r\n      jcl.add(\"myjar.jar\"); // Add some class source\r\n\r\n      jcl.getSystemLoader().setOrder(1); // Look in system class loader first\r\n      jcl.getLocalLoader().setOrder(2); // if not found look in local class loader\r\n      jcl.getParentLoader().setOrder(3); // if not found look in parent class loader\r\n      jcl.getThreadLoader().setOrder(4); // if not found look in thread context class loader\r\n      jcl.getCurrentLoader().setOrder(5); // if not found look in current class loader\r\n\r\n      // A custom class loader that extends org.xeustechnologies.jcl.ProxyClassLoader\r\n      MyLoader loader=new MyLoader();\r\n      loader.setOrder(6);\r\n\r\n      jcl.addLoader(loader); //Add custom loader\r\n    </code>\r\n\r\nEnable/Disable classloaders\r\n---------------------------\r\n\r\nJCL also provides a way to enable/disable classloaders. This can be done\r\nboth programmetically and by passing a JVM -D arg.\r\n\r\n    <code>\r\n      JarClassLoader jcl=new JarClassLoader();\r\n      jcl.add(\"myjar.jar\"); // Add some class source\r\n\r\n      //Disable parent class loader\r\n      jcl.getParentLoader().setEnabled(false);\r\n    </code>\r\n\r\nSimilarly a -D argument can be passed to the VM; this is done by passing\r\na boolean values to the loader’s class name.\r\n\r\n    <code>\r\n      -Dorg.xeustechnologies.jcl.AbstractClassLoader$ParentLoader=false\\\r\n      -Dmypack.MyLoader=false\r\n    </code>\r\n\r\nEnable OSGi boot delegation\r\n---------------------------\r\n\r\nSometimes it is required to delegate some classes to the parent loader;\r\nthis is part of the OSGi Spec for boot delegation. This can be enabled\r\nby passing the following argument to the JVM.\r\n\r\n    <code>\r\n      -Dosgi.bootdelegation=true\r\n    </code>\r\n\r\nAnd as spec’d, you can also pass classes and packages as a JVM argument\r\n\r\n    <code>\r\n      -Dorg.osgi.framework.bootdelegation=mypack.*\r\n    </code>\r\n\r\nBy default the OSGi boot delegation is not strict and if the class is\r\nnot found in the parent classloader then JCL will try to find it in\r\nother loaders. OSGi boot delegation can be made strict and a\r\nClassNotFoundException is thrown if the class is not found in parent.\r\n\r\n    <code>\r\n      -Dosgi.bootdelegation.strict=true\r\n    </code>\r\n\r\n**Note:** The order of OSGi boot loader cannot be changed. The osgi boot\r\ndelegation can also be turned on programetically, please see the\r\n*LoadTest.java* provided with the source.\r\n\r\nOther configuration\r\n-------------------\r\n\r\nSome other JCL tweaks.\r\n\r\n### Class collisions\r\n\r\nJCL by default ignore class collisions and the first class that is found\r\ngets loaded. It is also possible to throw exception on collision, this\r\nis done as follows:\r\n\r\n    <code>\r\n      -Djcl.suppressCollisionException=false\r\n    </code>\r\n\r\n### Missing Jars\r\n\r\nJCL by default ignores all missing jars/class sources. This default\r\nbehaviour can be changes both programmatically and on runtime:\r\n\r\n    <code>\r\n      -Djcl.suppressMissingResourceException=false\r\n    </code>\r\n\r\n### Using parent log config.\r\n\r\nJCL uses an isolated log4j logger, which sometimes spits out a lot of\r\nlines on the console. The default log level has now been lowered to INFO\r\nbut to disable it entirely and use the parent log config, pass the\r\nfollowing argument to JVM. *Version 2.3 and above does not use Log4J.*\r\n\r\n    <code>\r\n      -Djcl.isolateLogging=false\r\n    </code>\r\n\r\nMaven Dependency\r\n----------------\r\n\r\n    <code>\r\n      <dependency>\r\n        <groupId>org.xeustechnologies</groupId>\r\n        <artifactId>jcl-core</artifactId> \r\n        <version>2.4</version>\r\n      </dependency>\r\n    </code>\r\n"}