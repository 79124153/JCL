<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>jcl by kamranzafar</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>jcl</h1>
        <h2>Jar Class Loader, a configurable and dynamic custom classloader designed to create, manage and manipulate isolated Java classloaders in IoC frameworks and web applications.</h2>

        <section id="downloads">
          <a href="https://github.com/kamranzafar/JCL/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/kamranzafar/JCL/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/kamranzafar/JCL" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>Overview</h1>

<p>JCL is a configurable, dynamic and extensible custom classloader that
loads java classes directly from Jar files and other sources. The
motivation was to create isolated classloaders, which can be easily
integrated with IoC frameworks like Spring and with web applications.</p>

<p>The entire library, including it’s code-base and documentation is
available under a dual-license, whereby it can be used under the terms
and conditions of <a href="http://www.gnu.org/licenses/lgpl.html">LGPL</a> and
<a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a>.</p>

<h1>Installation</h1>

<p>To use JCL, download and build the JCL project and put jcl
(~~core~~2.x).jar and dependencies in the application’s classpath. See
the build section below and also check out the downloads section for
more details on the available builds and source.</p>

<p>JCL is also available in Maven Central Repository, which makes it very
easy to use in maven projects as a dependency.</p>

<h1>Building JCL</h1>

<p>JCL is a multi-module maven project that has four modules as shown
below:</p>

<pre><code> JCL
  |---&gt; core
  |---&gt; spring
  |---&gt; test-jcl
  |---&gt; test-web
</code></pre>

<p>The test-* modules create resources to run the unit tests and a sample
web application. The core module builds an artifact with all the main
JCL class files. The spring module generates an artifact for spring
integration.</p>

<p>To build JCL, check-out the source code of JCL2 from
<a href="https://github.com/xeusman/JCL">github</a> and run the following command:</p>

<pre><code> mvn clean install
</code></pre>

<p>This command will create jcl-core and jcl-spring artifacts, and will
also create a sample war file to test JCL web integration. It will also
copy the dependencies of each artifact in the dependecies folder.</p>

<h1>Requirements</h1>

<p>JCL requires JDK 1.5 or later; and will pull in all its dependencies
using maven.</p>

<h1>Usage</h1>

<p>Below is a little tutorial on JCL v2 with examples. Please also see the
overview section for installation.</p>

<h2>What’s new in v2</h2>

<p>Version 2.x now deprecates version 1.x so we recommend users to switch
to version 2, which was a complete refactoring of version 1 and has a
better design with a lot more features. Following is a list of <em>some</em>
updates and changes in v2.x:</p>

<ul>
<li>  Total refactoring of version 1</li>
<li>  Maven is being used for project management instead of ANT</li>
<li>  Added more robust spring and web support</li>
<li>  Added OSGi boot loading</li>
<li>  JCL 2 is more customizable and configurable</li>
<li>  etc. etc.</li>
</ul><h2>Using JCL</h2>

<p>JCL is a light weight API and has only a few but useful classes. Here is
a simple example on how to programmatically use JCL. JarClassLoader has
an arguments-constructor and add methods that take jar-file/class-folder
paths, URLs and InputStreams.</p>

<pre><code>  JarClassLoader jcl = new JarClassLoader();

  //Loading classes from different sources
  jcl.add("myjar.jar");
  jcl.add(new URL("http://myserver.com/myjar.jar"));
  jcl.add(new FileInputStream("myotherjar.jar"));
  jcl.add("myclassfolder/");

  //Recursively load all jar files in the folder/sub-folder(s)
  jcl.add("myjarlib/");

  JclObjectFactory factory = JclObjectFactory.getInstance();

  //Create object of loaded class
  Object obj = factory.create(jcl, "mypack.MyClass");
</code></pre>

<p>Now we can use reflection to invoke methods of this object. It is also
possible to create object proxies and call methods the normal way, this
is done by using cast (able) methods available in JclUtils class
explained later.</p>

<h2>Creating a JCL Context</h2>

<p>In order to access the created JarClassLoader instance from any where in
the application a <em>JclContext</em> must be created. The
<em>DefaultContextLoader</em> provides a way to create this context for a
single programmatically created JarClassLoader instance.</p>

<pre><code>  JarClassLoader jcl = new JarClassLoader();
  jcl.add("myjarlib/");

  DefaultContextLoader context=new DefaultContextLoader(jcl);
  context.loadContext();
</code></pre>

<p>Now “jcl” can be accessed from anywhere in the application as follows.</p>

<pre><code>  JarClassLoader jcl=JclContext.get(); // returns the Default JCL instance
</code></pre>

<p>It is also possible to create an XML configuration file for JCL and use
<em>XmlContextLoader</em> to create the context.</p>

<h2>Using JCL in Web Applications</h2>

<p>One of the motivations behind JCL was to be able to create multiple
isolated classloaders in a single web application hosted on application
servers like JBoss, Tomcat etc. This is achieved with
JclContextLoaderListener.</p>

<p>The JCL configuration is put in a XML file and then the
<em>JclContextLoaderListener</em> is used to load the context. Below is an
example of JCL XML configuration.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jcl-context&gt;
    &lt;jcl name="jcl1"&gt;
        &lt;loaders&gt;
            &lt;loader name="jcl.parent"&gt;
                &lt;order&gt;3&lt;/order&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/loader&gt;
            &lt;loader name="jcl.local"&gt;
                &lt;order&gt;1&lt;/order&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/loader&gt;
            &lt;loader name="jcl.current"&gt;
                &lt;enabled&gt;false&lt;/enabled&gt;
            &lt;/loader&gt;
            &lt;loader name="jcl.thread"&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/loader&gt;
            &lt;loader name="jcl.system"&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/loader&gt;
            &lt;loader name="jcl.bootosgi"&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
                &lt;strict&gt;true&lt;/strict&gt;
                &lt;bootDelegation&gt;mypack.system.*&lt;/bootDelegation&gt;
            &lt;/loader&gt;
            &lt;loader name="custom" class="mypack.MyLoader"&gt;
                &lt;order&gt;2&lt;/order&gt;
                &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;/loader&gt;
        &lt;/loaders&gt;
        &lt;sources&gt;
            &lt;source&gt;webapp:WEB-INF/mylib/myjar.jar&lt;/source&gt;
            &lt;source&gt;webapp:myotherjar.jar&lt;/source&gt;
        &lt;/sources&gt;
    &lt;/jcl&gt;
    &lt;jcl name="jcl2"&gt;
        &lt;sources&gt;
            &lt;source&gt;webapp:WEB-INF/myjarlib/&lt;/source&gt;
        &lt;/sources&gt;
    &lt;/jcl&gt;
&lt;/jcl-context&gt;
</code></pre>

<p>In this example two classloaders are created in a single context. The
source paths starting with <strong>webapp:</strong> are treated as paths to internal
web application jar files and folders. After this configuration, the
context can be loaded in the web application by adding the
JclContextLoaderListener in the application’s web.xml file.</p>

<pre><code> &lt;context-param&gt;
    &lt;param-name&gt;jcl-context&lt;/param-name&gt;
    &lt;param-value&gt;
      classpath:jcl.xml
    &lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;listener&gt;
    &lt;listener-class&gt;org.xeustechnologies.jcl.web.JclContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;
</code></pre>

<p>The JCL instances can then be accessed by name from anywhere in the web
application as shown below.</p>

<pre><code>  JarClassLoader jcl1=JclContext.get("jcl1");
  JarClassLoader jcl2=JclContext.get("jcl2");
</code></pre>

<h3>Sample web application</h3>

<p>The JCL project also includes a sample web application that demonstrates
JCL web-app integration. The jcltest.war file is created in the test-web
module at jcl-project/test-web/target when the project is built. The
content of the war file is also under the same module and is located in
jcl-project/test-web/src/main folder. The exploded war folder contains
all the files that clearly shows the usage of JCL in web applications.</p>

<p>After deploying the sample web application, go to
<a href="http://server-name:8080/jcltest">http://server-name:8080/jcltest</a>; this
will print “Hello World” on the screen with classloader details. This
message is returned from a JCL-loaded object, see
jcl-project/test-web/src/main/jcltest.war/index.jsp for more details.</p>

<h2>Using JCL with Spring Framework</h2>

<p>JCL can be used with spring framework. JCL v2 provides Spring XML
extension to load beans via JCL. The JCL bean is created using the new
<strong>jcl:jcl</strong> element and spring beans can reference the jcl bean by using
the <strong>jcl:jcl-ref</strong> element as shown in the example below. These
elements are defined in the jcl-schema.xsd. This also works well in a
web application using the Spring ContextLoaderListener. In addition to
this JCL v2 also supports the older way of Spring integration, please
see the spring-test.xml file provided with the source.</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jcl="http://www.xeustechnologies.org/schema/jcl"
    xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.xeustechnologies.org/schema/jcl http://www.xeustechnologies.org/schema/jcl/jcl.xsd"&gt;

    &lt;jcl:jcl id="jcl1"&gt;
        &lt;constructor-arg&gt;
            &lt;list&gt;
                &lt;value&gt;target/test-jcl.jar&lt;/value&gt;
            &lt;/list&gt;
        &lt;/constructor-arg&gt;
    &lt;/jcl:jcl&gt;

    &lt;jcl:jcl id="jcl2"&gt;
        &lt;constructor-arg&gt;
            &lt;list&gt;
                &lt;value&gt;target/test-jcl.jar&lt;/value&gt;
            &lt;/list&gt;
        &lt;/constructor-arg&gt;
    &lt;/jcl:jcl&gt;

    &lt;bean id="test1" class="org.xeustechnologies.jcl.test.Test"&gt;
        &lt;jcl:jcl-ref ref="jcl1" /&gt;
        &lt;constructor-arg ref="name"/&gt;
        &lt;property name="lastName"&gt;
                &lt;value&gt;Zafar&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="name" class="java.lang.String"&gt;
        &lt;jcl:jcl-ref ref="jcl2" /&gt;
        &lt;constructor-arg&gt;
            &lt;value&gt;Kamran&lt;/value&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<h2>Casting objects of types loaded in JCL</h2>

<p>Java does not allow casting objects of types loaded in a different
classloader; such casting attempt results in a <em>ClassCastException</em>. But
sometimes it is necessary to cast objects to obtain interface references
loaded in the current classloader. E.g. suppose that an API
implementation is loaded using JCL and the API itself is loaded in the
current classloader, now it is easy to use the interface reference to
invoke methods than using reflection. JCL provides a few ways to obtain
interface references and to convert the JCL-loaded objects into castable
objects. This is actually done by internally creating proxies for the
JCL-loaded objects. JCL, as of version 2.2, can also create
<a href="http://cglib.sourceforge.net/">cglib</a> dynamic proxies apart from the
regular jdk proxies, which makes it possible to create proxies for any
class not just interfaces. It is also possible to create
auto-proxies/castable-objects from the object factory, which is very
handy because then the objects can be used and casted the normal way.</p>

<h3>Auto creating castable objects from factory</h3>

<p>In version 2.2 and later, the JclObjectFactory can be used to
auto-create “castable” objects, by passing true to the getInstance
method. Now every time an object is created, it can be casted to
references in the current classloader without the need of JclUtils. By
default JCL2 uses jdk proxies but that can be changed by specifying the
proxy provider, as shown in the example below.</p>

<pre><code>  JarClassLoader jcl = new JarClassLoader();
  jcl.add("myapi-impl.jar"); //Load jar file

  // Set default to cglib (from version 2.2.1)
  ProxyProviderFactory.setDefaultProxyProvider( new CglibProxyProvider() );

  //Create a factory of castable objects/proxies
  JclObjectFactory factory = JclObjectFactory.getInstance(true);

  //Create and cast object of loaded class
  MyInterface mi = (MyInterface) factory.create(jcl,"myapi.impl.MyInterfaceImpl");
</code></pre>

<p>Auto proxying can also be dynamically enabled using a jvm command line
argument:</p>

<pre><code>  -Djcl.autoProxy=true
</code></pre>

<h3>Casting objects when required</h3>

<p>By default the object factory creates objects of classes loaded in JCL
without proxies. So in order to cast/clone the objects, JclUtils class
is used as shown in the example below:</p>

<pre><code>  JarClassLoader jcl = new JarClassLoader();
  jcl.add("myapi-impl.jar"); //Load jar file

  //Create default factory
  JclObjectFactory factory = JclObjectFactory.getInstance();

  //Create object of loaded class
  Object obj = factory.create(jcl,"myapi.impl.MyInterfaceImpl");

  //Obtain interface reference in the current classloader
  MyInterface mi = JclUtils.cast(obj, MyInterface.class);

  //Convert the object into a castable object in the current classloader (jdk proxy)
  MyInterface mi1 = (MyInterface) JclUtils.toCastable(obj, MyInterface.class);

  //Clone "Serializable" object into a castable object in the current classloader
  //The JCL-loaded object must implement Serializable
  //This method is now deprecated and the use of deepClone is recommended
  MyInterface mi2 = (MyInterface) JclUtils.clone(obj);

  //Clone any object Serializable and non-Serializable
  MyInterface mi2 = (MyInterface) JclUtils.deepClone(obj);
</code></pre>

<h2>Manipulating class loading order &amp; adding custom classloaders</h2>

<p>JCL v2 by default looks for classes in five places in order, local JCL
class loader (order=1), current class loader (order=2), parent class
loader (order=3), in thread context class loader (order=4) and then in
system class loader (order=5). There is a sixth class loader available
for Osgi boot delegation; it is described later in the document. In
addition to built-in loaders, more class loaders can be added by
extending the <em>org.xeustechnologies.jcl.ProxyClassLoader</em> class. Each
loader has a loading order and the default loading orders can be
changed. Below is an example that shows how to do this:</p>

<pre><code>  JarClassLoader jcl=new JarClassLoader();
  jcl.add("myjar.jar"); // Add some class source

  jcl.getSystemLoader().setOrder(1); // Look in system class loader first
  jcl.getLocalLoader().setOrder(2); // if not found look in local class loader
  jcl.getParentLoader().setOrder(3); // if not found look in parent class loader
  jcl.getThreadLoader().setOrder(4); // if not found look in thread context class loader
  jcl.getCurrentLoader().setOrder(5); // if not found look in current class loader

  // A custom class loader that extends org.xeustechnologies.jcl.ProxyClassLoader
  MyLoader loader=new MyLoader();
  loader.setOrder(6);

  jcl.addLoader(loader); //Add custom loader
</code></pre>

<h2>Enable/Disable classloaders</h2>

<p>JCL also provides a way to enable/disable classloaders. This can be done
both programmetically and by passing a JVM -D arg.</p>

<pre><code>  JarClassLoader jcl=new JarClassLoader();
  jcl.add("myjar.jar"); // Add some class source

  //Disable parent class loader
  jcl.getParentLoader().setEnabled(false);
</code></pre>

<p>Similarly a -D argument can be passed to the VM; this is done by passing
a boolean values to the loader’s class name.</p>

<pre><code>  -Dorg.xeustechnologies.jcl.AbstractClassLoader$ParentLoader=false\
  -Dmypack.MyLoader=false
</code></pre>

<h2>Enable OSGi boot delegation</h2>

<p>Sometimes it is required to delegate some classes to the parent loader;
this is part of the OSGi Spec for boot delegation. This can be enabled
by passing the following argument to the JVM.</p>

<pre><code>  -Dosgi.bootdelegation=true
</code></pre>

<p>And as spec’d, you can also pass classes and packages as a JVM argument</p>

<pre><code>  -Dorg.osgi.framework.bootdelegation=mypack.*
</code></pre>

<p>By default the OSGi boot delegation is not strict and if the class is
not found in the parent classloader then JCL will try to find it in
other loaders. OSGi boot delegation can be made strict and a
ClassNotFoundException is thrown if the class is not found in parent.</p>

<pre><code>  -Dosgi.bootdelegation.strict=true
</code></pre>

<p><strong>Note:</strong> The order of OSGi boot loader cannot be changed. The osgi boot
delegation can also be turned on programetically, please see the
<em>LoadTest.java</em> provided with the source.</p>

<h2>Other configuration</h2>

<p>Some other JCL tweaks.</p>

<h3>Class collisions</h3>

<p>JCL by default ignore class collisions and the first class that is found
gets loaded. It is also possible to throw exception on collision, this
is done as follows:</p>

<pre><code>  -Djcl.suppressCollisionException=false
</code></pre>

<h3>Missing Jars</h3>

<p>JCL by default ignores all missing jars/class sources. This default
behaviour can be changes both programmatically and on runtime:</p>

<pre><code>  -Djcl.suppressMissingResourceException=false
</code></pre>

<h3>Using parent log config.</h3>

<p>JCL uses an isolated log4j logger, which sometimes spits out a lot of
lines on the console. The default log level has now been lowered to INFO
but to disable it entirely and use the parent log config, pass the
following argument to JVM. <em>Version 2.3 and above does not use Log4J.</em></p>

<pre><code>  -Djcl.isolateLogging=false
</code></pre>

<h2>Maven Dependency</h2>

<pre><code>  &lt;dependency&gt;
    &lt;groupId&gt;org.xeustechnologies&lt;/groupId&gt;
    &lt;artifactId&gt;jcl-core&lt;/artifactId&gt; 
    &lt;version&gt;2.4&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>
      </section>
    </div>

    
  </body>
</html>